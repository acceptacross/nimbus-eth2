<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nim routines, procedures, functions, templates, macros - The Auditors Handbook to Nimbus Beacon Chain</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="02_the_Nim_programming_language.html"><strong aria-hidden="true">2.</strong> The Nim Programming Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02.1_nim_routines_proc_func_templates_macros.html" class="active"><strong aria-hidden="true">2.1.</strong> Nim routines, procedures, functions, templates, macros</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02.1.1_operators_bit_manipulation.html"><strong aria-hidden="true">2.1.1.</strong> Operators, bit manipulation</a></li><li class="chapter-item expanded "><a href="02.1.4_closure_iterators.html"><strong aria-hidden="true">2.1.2.</strong> Closure iterators</a></li></ol></li><li class="chapter-item expanded "><a href="02.2_stack_ref_ptr_types.html"><strong aria-hidden="true">2.2.</strong> Datatypes: value, ref, ptr</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02.2.2_casting_and_low_level_memory_representation.html"><strong aria-hidden="true">2.2.1.</strong> Casting and low-level memory representation</a></li><li class="chapter-item expanded "><a href="02.2.3_memory_management_gc.html"><strong aria-hidden="true">2.2.2.</strong> Memory Management and Garbage Collection</a></li><li class="chapter-item expanded "><a href="02.2.4_generics_types_static_types.html"><strong aria-hidden="true">2.2.3.</strong> Generic types & static types</a></li><li class="chapter-item expanded "><a href="02.2.5_arrays_openarrays_strings_cstring.html"><strong aria-hidden="true">2.2.4.</strong> Arrays, openarrays, strings, C-strings</a></li></ol></li><li class="chapter-item expanded "><a href="02.3_correctness_distinct_mutability_effects_exceptions.html"><strong aria-hidden="true">2.3.</strong> Correctness: distinct, mutability, effects, exceptions</a></li><li class="chapter-item expanded "><a href="02.4_debugging_Nim_sanitizers_fuzzers.html"><strong aria-hidden="true">2.4.</strong> Debugging Nim, sanitizers, fuzzers</a></li><li class="chapter-item expanded "><a href="02.5_foreign_lang_to_from_interop.html"><strong aria-hidden="true">2.5.</strong> Foreign lang interop: C and C++</a></li><li class="chapter-item expanded "><a href="02.8_Nim_threat_model.html"><strong aria-hidden="true">2.6.</strong> Nim threat model</a></li><li class="chapter-item expanded "><a href="02.10_Nim_FAQ.html"><strong aria-hidden="true">2.7.</strong> Nim FAQ</a></li></ol></li><li class="chapter-item expanded "><a href="03_nbc_nimbus_beacon_chain.html"><strong aria-hidden="true">3.</strong> Nimbus NBC - The Nim-Beacon-Chain</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03.2_build_system_and_dependencies.html"><strong aria-hidden="true">3.1.</strong> Build system and dependencies</a></li><li class="chapter-item expanded "><a href="03.5_the_threat_model.html"><strong aria-hidden="true">3.2.</strong> Threat model</a></li></ol></li><li class="chapter-item expanded "><a href="04_serialization.html"><strong aria-hidden="true">4.</strong> Serialization</a></li><li class="chapter-item expanded "><a href="05_async_with_chronos.html"><strong aria-hidden="true">5.</strong> Async/Await with Chronos</a></li><li class="chapter-item expanded "><a href="06_cryptography_and_rng.html"><strong aria-hidden="true">6.</strong> Cryptography</a></li><li class="chapter-item expanded "><a href="07_nim-eth.html"><strong aria-hidden="true">7.</strong> Ethereum Networking</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Auditors Handbook to Nimbus Beacon Chain</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="nim-routines"><a class="header" href="#nim-routines">Nim Routines</a></h1>
<p>!!! warning
This auditors' handbook is frozen and obsolete; the <a href="https://nim-lang.org/docs/manual.html">Nim language manual</a> alongside <a href="https://nim-lang.org/documentation.html">other Nim documentation</a>, <a href="https://status-im.github.io/nim-style-guide/">Status Nim style guide</a>, <a href="https://github.com/status-im/nim-chronos/blob/master/docs/src/SUMMARY.md">Chronos guides</a>, and <a href="https://nim-by-example.github.io/getting_started/">Nim by Example</a> supercede it.</p>
<p>Nim offers several kinds of &quot;routines&quot; that:</p>
<ul>
<li>do computation</li>
<li>produce side-effect</li>
<li>generate code</li>
</ul>
<p>Those are:</p>
<ul>
<li><code>proc</code> and <code>func</code></li>
<li><code>method</code></li>
<li><code>converter</code></li>
<li><code>iterator</code></li>
<li><code>template</code></li>
<li><code>macro</code></li>
</ul>
<h2 id="proc-and-func"><a class="header" href="#proc-and-func"><code>proc</code> and <code>func</code></a></h2>
<p><code>proc</code> and <code>func</code> are the most basic routines.</p>
<p>At the moment, Nim requires forward declaration of proc and func.
Also it prevents circular dependencies, this means that a procedure is
always coming from one of the imports.</p>
<p>Additionally, all dependencies are submodules and a proc can be found by greping
<code>procname*</code>, the <code>*</code> being the export marker.</p>
<p>The only exception being the standard library. Procedures from the standard library are all listed in &quot;<a href="https://nim-lang.org/docs/theindex.html">The Index</a>&quot;.</p>
<h3 id="function-call-syntax"><a class="header" href="#function-call-syntax">Function call syntax</a></h3>
<p>Nim provides flexible call syntax, the following are possible:</p>
<pre><code class="language-Nim">prof foo(a: int) =
  discard

foo(a)
foo a
a.foo()
a.foo
</code></pre>
<p>Additionally this is also possible for strings:</p>
<pre><code class="language-Nim">let a = fromHex&quot;0x12345&quot; # Without spaces
</code></pre>
<p>Nim doesn't enforce namespacing by default but is an option</p>
<pre><code class="language-Nim">let a = byteutils.fromhex&quot;0x12345&quot;
</code></pre>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>Mutable parameters must be tagged with <code>var</code></p>
<p>TODO</p>
<h3 id="symbol-resolution"><a class="header" href="#symbol-resolution">Symbol resolution</a></h3>
<p>If 2 procedures are visible in the same module (a module is a file) and
have the same name the compiler will infer which to call from the arguments
signatures. In case both are applicable, the compiler will throw an &quot;ambiguous call&quot; compile-time error.</p>
<p>Note that a procedure specialized to a concrete type has priority over a generic procedure, for example a procedure for int64 over a procedure for all number types.</p>
<h3 id="func-and-side-effect-analysis"><a class="header" href="#func-and-side-effect-analysis"><code>func</code> and side effect analysis</a></h3>
<p>In Nim a proc is considered to have side-effect if it accesses a global variable.
Mutating a declared function parameter is not considered a side-effect as there is no access to a global variable.
Printing to the standard output or reading the standard input is considered a sideeffect.</p>
<p><code>func</code> are syntactic sugar for <code>proc</code> without sideeffects. In particular this means that <code>func</code> behaviors are fully determined by their input parameters.</p>
<p>In the codebase, logging at the <code>trace</code> level are not considered a sideeffect.</p>
<p>Additionally some logging statements and metrics statement may be in an explicit <code>{.noSideEffect.}:</code> code-block.</p>
<h3 id="returning-values"><a class="header" href="#returning-values">Returning values</a></h3>
<p>There are 3 syntaxes to return a value from a procedure:</p>
<ol>
<li>The return statement</li>
<li>The implicit <code>result</code> variable</li>
<li>The &quot;last statement as expression&quot;</li>
</ol>
<pre><code class="language-Nim">proc add1(x: int): int =
  return x + 1

proc add2(x: int): int =
  result = x + 2

proc add3(x: int): int =
  x + 3
</code></pre>
<p>The main differences are:</p>
<ol>
<li><code>return</code> allows early returns, in particular from a loop.</li>
<li><code>result</code> offers Return Value Optimization and Copy Elision
which is particularly valuable for array types.</li>
<li>Requires the last statement to be a valid expression.
This is particularly interesting for conditional return values
as forgetting to set the value in a branch will be a compile-time error,
for example:
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    a
  else:
    echo &quot;heavy processing&quot;
    b
</code></pre>
Omitting <code>a</code> or <code>b</code> will be a compiletime error, unlike
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    return a
  else:
    echo &quot;heavy processing&quot;
    # Forgot to return b
</code></pre>
<pre><code class="language-Nim">proc select(ctl: bool, a, b: int): int =
  if ctl:
    echo &quot;heavy processing&quot;
    result = a
  else:
    echo &quot;heavy processing&quot;
    # Forgot to result = b
</code></pre>
</li>
</ol>
<p>Due to the differences we prefer using the &quot;last statement as expression&quot; unless</p>
<ul>
<li>copying the type is expensive (SHA256 hash for example)</li>
<li>or we need early returns</li>
</ul>
<h4 id="ignoring-return-values"><a class="header" href="#ignoring-return-values">Ignoring return values</a></h4>
<p>Unlike C, return values MUST be used or explicitly discarded.</p>
<h4 id="mutable-return-values"><a class="header" href="#mutable-return-values">Mutable return values</a></h4>
<p>TODO</p>
<h3 id="at-a-low-level"><a class="header" href="#at-a-low-level">At a low-level</a></h3>
<h4 id="argument-passing"><a class="header" href="#argument-passing">Argument passing</a></h4>
<p>Nim passes arguments by value if they take less than 3*sizeof(pointer) (i.e. 24 bytes on 64-bit OS) and passes them by pointer with the C backend or reference with the C++ backend if they are bigger.
Mutable arguments are always passed by pointer.</p>
<p>This behavior can be changed on a type-by-type bases by tagging them {.bycopy.} or {.byref.}. This is only used for interfacing with non-Nim code.</p>
<h4 id="stacktraces"><a class="header" href="#stacktraces">Stacktraces</a></h4>
<p>With <code>--stacktrace:on</code>, Nim create a stackframe on <code>proc</code> entry and destroys it on exit. This is used for reporting stacktraces.</p>
<p>NBC is always compiled with <code>--stacktraces:on</code></p>
<p>NBC uses <a href="https://github.com/ianlancetaylor/libbacktrace">libbacktrace</a> to have less costly stacktraces.</p>
<h4 id="name-in-the-c-code-or-assembly"><a class="header" href="#name-in-the-c-code-or-assembly">Name in the C code or Assembly</a></h4>
<p><code>proc</code> and <code>func</code> are materialized in the produced C code with name-mangling appended at the end. For the purpose of building Nim libraries, the name can be controlled by:</p>
<ul>
<li><code>{.exportc.}</code> so that the generated C name is the same as Nim</li>
<li>`{.exportc: &quot;specific_name&quot;.} to generate a specific name</li>
</ul>
<h2 id="method"><a class="header" href="#method"><code>method</code></a></h2>
<p><code>method</code>s are used for dynamic dispatch when an object has an inherited subtype only known at runtime.</p>
<p><code>method</code> are dispatched using a dispatch tree in the C code instead of a VTable.</p>
<p>There might be some cases where <code>method</code> were used not for their intended purpose</p>
<h2 id="converter"><a class="header" href="#converter"><code>converter</code></a></h2>
<p>Converters are procedures that are implicitly called on a value to change its type.</p>
<p>For example with a fictional option type that automatically extracts the boxed type.</p>
<pre><code class="language-Nim">type Option[T] = object
  case hasValue: bool
  of true:
    value: T
  else:
    discard

converter get[T](x: Option[T]): T =
  x.value

let x = Option[int](hasValue: true, value: 1)
let y = Option[int](hasValue: true, value: 2)

let z = x + y
</code></pre>
<p>Even though the <code>+</code> operator is not defined for <code>Option[int]</code> it is defined for <code>int</code> and Nim implicitly calls the converter.</p>
<p><code>converter</code> are seldom used in the codebase as we prefer explicit over implicit.</p>
<p>Note that in case an operation is defined on both the convertible and the converted type, the operation without conversion should be preferred however <a href="https://github.com/nim-lang/Nim/issues/7416">the compiler might throw an ambiguous call instead</a>.</p>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>Iterators are construct that transforms a for loop.</p>
<p>For example to iterate on a custom array collection</p>
<pre><code class="language-Nim">const MaxSize = 7

type SmallVec[T] = object
    buffer*: array[MaxSize, T]
    len*: int

iterator items*[T](a: SmallVec[T]): T =
  for i in 0 ..&lt; a.len:
    yield a.data[i]
</code></pre>
<p>Now iterating becomes</p>
<pre><code class="language-Nim">for value in a.items():
  echo a
</code></pre>
<p>A singly-linked list forward iterator could be implemented as</p>
<pre><code class="language-Nim">iterator items[T](head: ref T): ref T =
  ## Singly-linked list iterator
  assert: not head.isNil
  var cur = head
  while true:
    let next = cur.next
    yield cur
    cur = next
    if cur.isNil:
      break
</code></pre>
<p>a doubly-linked list backward iterator as</p>
<pre><code class="language-Nim">iterator backward[T](tail: ptr T): ptr T =
  var cur = tail
  while not cur.isNil:
    let prev = cur.prev
    yield cur
    cur = prev
</code></pre>
<p>an iterator to unpack individual bits from a byte as:</p>
<pre><code class="language-Nim">iterator unpack(scalarByte: byte): bool =
  yield bool((scalarByte and 0b10000000) shr 7)
  yield bool((scalarByte and 0b01000000) shr 6)
  yield bool((scalarByte and 0b00100000) shr 5)
  yield bool((scalarByte and 0b00010000) shr 4)
  yield bool((scalarByte and 0b00001000) shr 3)
  yield bool((scalarByte and 0b00000100) shr 2)
  yield bool((scalarByte and 0b00000010) shr 1)
  yield bool( scalarByte and 0b00000001)
</code></pre>
<p>In all cases, the syntax to iterate on the collection remains:</p>
<pre><code class="language-Nim">for value in a.items():
  echo a

for value in b.backward():
  echo b

for bit in s.unpack():
  echo s
</code></pre>
<p>The echo is inlined at &quot;yield&quot;.</p>
<p>Iterators are not present in the produced C code, they are always inlined at the callsite.</p>
<p>Iterators are prone to code bloat, for example</p>
<pre><code class="language-Nim">iterator iterate[T](s: seq[T], backward: bool): T =
  if backward:
    for i in s.len-1 .. 0:
      yield s[i]
  else:
    for i in 0 ..&lt; s.len:
      yield s[i]

for value in s.iterate(backward = false):
  ## Long-series of operations
  echo value
</code></pre>
<p>The long series of operation will be duplicated.</p>
<h3 id="items-and-pairs"><a class="header" href="#items-and-pairs"><code>items</code> and <code>pairs</code></a></h3>
<p>The <code>items</code> and <code>pairs</code> iterator are special cased and implictly call
if there is respectively one and two iteration variables hence:</p>
<pre><code class="language-Nim">for x in collection:
  echo x
</code></pre>
<p>will automatically call the <code>items</code> proc defined for the collection (or error)</p>
<pre><code class="language-Nim">for x, y in collection:
  echo x
  echo y
</code></pre>
<p>will automatically call the <code>pairs</code> proc defined for the collection (or error)</p>
<h3 id="fields-and-fieldpairs"><a class="header" href="#fields-and-fieldpairs"><code>fields</code> and <code>fieldPairs</code></a></h3>
<p><code>fields</code> and <code>fieldsPairs</code> are iterator-like magic, that allow &quot;iterating&quot; on an object field. Note that those are unrolled at compile-time.</p>
<h2 id="closures-and-closure-iterators"><a class="header" href="#closures-and-closure-iterators">Closures and closure iterators</a></h2>
<p>Will be covered in a dedicated section.</p>
<p>They are the backbone of Chronos, our async/await framework and also
have a major potential for memory leaks.</p>
<h2 id="template"><a class="header" href="#template"><code>template</code></a></h2>
<p><code>template</code>s in Nim allows raw code substitution.</p>
<p><code>templates</code> are hygienic and typechecked unlike the C preprocessor.
Also they create their own scope unless tagged with the <code>{.dirty.}</code> pragma.</p>
<p>A major issue with templates is that as they &quot;copy-paste&quot; code, it is very easy to misuse them and do a computation twice.</p>
<p>For instance</p>
<pre><code class="language-Nim">proc foo(): int =
  echo &quot;launch missile&quot;
  return 1

template doSomething(a: int) =
  process(a)
  log(a)
</code></pre>
<p>This would be transformed to:</p>
<pre><code class="language-Nim">process(foo())
log(foo())
</code></pre>
<p>and triggers the &quot;launch missile&quot; side-effect twice.</p>
<p>Another issue with templates is that they may not generate stacktraces properly as
they are not materialized in the C code.</p>
<h3 id="symbol-visibility-and" class="inject."><a class="header" href="#symbol-visibility-and">Symbol visibility and</a></h3>
<p>TODO</p>
<h2 id="macro"><a class="header" href="#macro"><code>macro</code></a></h2>
<p>TODO</p>
<h2 id="the-do-notation"><a class="header" href="#the-do-notation">The <code>do</code> notation</a></h2>
<p>TODO</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="02_the_Nim_programming_language.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="02.1.1_operators_bit_manipulation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="02_the_Nim_programming_language.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="02.1.1_operators_bit_manipulation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
